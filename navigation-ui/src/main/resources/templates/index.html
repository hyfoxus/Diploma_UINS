<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Graph Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" />
    <link href="styles.css" rel="stylesheet" />
</head>
<body>
<div>
    <label for="schemeSelect">Select Scheme:</label>
    <select id="schemeSelect" onchange="loadScheme()">
        <!-- Options will be populated dynamically -->
    </select>
</div>
<div class="container">
    <div id="mynetwork"></div>
    <div id="details"></div>
</div>
<button onclick="saveGraph()">Save Graph</button>
<script>
    var nodes = new vis.DataSet([]);
    var edges = new vis.DataSet([]);

    var container = document.getElementById('mynetwork');
    var data = {
        nodes: nodes,
        edges: edges
    };
    var options = {
        edges: {
            smooth: false // Ensure edges are straight
        },
        physics: {
            enabled: false // Disable physics to maintain angles
        }
    };

    var network = new vis.Network(container, data, options);

    const SCALE_FACTOR = 20;
    function loadScheme() {
        var scheme = document.getElementById('schemeSelect').value;
        fetch(`/api/graph/${scheme}`)
            .then(response => response.json())
            .then(graph => {
                nodes.clear();
                edges.clear();

                let nodePositions = {};
                let visitedNodes = new Set();

                function dfs(nodeId, x, y) {
                    if (visitedNodes.has(nodeId)) return;
                    visitedNodes.add(nodeId);
                    nodePositions[nodeId] = { x, y };

                    graph.edges.forEach(edge => {
                        if (edge.from === nodeId && !visitedNodes.has(edge.to)) {
                            const length = (edge.length || 100) * SCALE_FACTOR;
                            const angle = edge.direction - 90 || 0;
                            const radianAngle = angle * (Math.PI / 180);
                            const newX = x + length * Math.cos(radianAngle);
                            const newY = y + length * Math.sin(radianAngle);
                            dfs(edge.to, newX, newY);
                        } else if (edge.to === nodeId && !visitedNodes.has(edge.from)) {
                            const length = edge.length || 100;
                            const angle = edge.direction || 0;
                            const radianAngle = (angle + 180) * (Math.PI / 180);
                            const newX = x + length * Math.cos(radianAngle);
                            const newY = y + length * Math.sin(radianAngle);
                            dfs(edge.from, newX, newY);
                        }
                    });
                }

                if (graph.nodes.length > 0) {
                    dfs(graph.nodes[0].id, 0, 0);
                }

                graph.nodes.forEach(node => {
                    if (nodePositions[node.id]) {
                        node.x = nodePositions[node.id].x;
                        node.y = nodePositions[node.id].y;
                    }
                    nodes.add({
                        ...node,
                        shape: 'dot',
                        size: 10,
                        title: `Node ${node.id}`
                    });
                });

                edges.add(graph.edges.map(edge => ({
                    ...edge
                })));
            });
    }

    window.onload = function() {
        fetch('/api/graph/list')
            .then(response => response.json())
            .then(schemes => {
                var schemeSelect = document.getElementById('schemeSelect');
                schemes.forEach(schemeId => {
                    var option = document.createElement('option');
                    option.value = schemeId;
                    option.textContent = `Scheme id ${schemeId}`;
                    schemeSelect.appendChild(option);
                });
                schemeSelect.value = schemes[0];
                loadScheme();
            });
    };

    network.on("click", function (params) {
        if (params.nodes.length > 0) {
            var nodeId = params.nodes[0];
            var node = nodes.get(nodeId);
            displayDetails(node, 'Node');
        } else if (params.edges.length > 0) {
            var edgeId = params.edges[0];
            var edge = edges.get(edgeId);
            displayDetails(edge, 'Edge');
        }
    });

    function displayDetails(item, type) {
        var detailsDiv = document.getElementById('details');
        detailsDiv.innerHTML = `<h3>${type} Details</h3>`;
        for (var key in item) {
            if (item.hasOwnProperty(key)) {
                detailsDiv.innerHTML += `<p><strong>${key}:</strong> ${item[key]}</p>`;
            }
        }
    }

    function saveGraph() {
        var updatedGraph = {
            nodes: nodes.get(),
            edges: edges.get()
        };

        fetch('/api/graph', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(updatedGraph)
        });
    }

</script>
</body>
</html>
