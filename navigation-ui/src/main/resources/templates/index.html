<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Graph Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet" />
    <link href="styles.css" rel="stylesheet" />
</head>
<body>
<div id="toolbar">
    <label for="schemeSelect">Select Scheme:</label>
    <select id="schemeSelect" onchange="loadScheme()">
        <!-- Options will be populated dynamically -->
    </select>
    <button onclick="saveGraph()">Save Graph</button>
    <button onclick="createScheme()">Create New Scheme</button> <!-- New button for creating schemes -->
    <button onclick="addVertex()">Add Vertex</button>
    <button onclick="addEdge()">Add Edge</button>
</div>
<div class="container">
    <div id="mynetwork"></div>
    <div id="details"></div>
</div>
<button onclick="saveGraph()">Save Graph</button>
<script>
    var nodes = new vis.DataSet([]);
    var edges = new vis.DataSet([]);

    var container = document.getElementById('mynetwork');
    var data = {
        nodes: nodes,
        edges: edges
    };
    var options = {
        edges: {
            smooth: false // Ensure edges are straight
        },
        physics: {
            enabled: false // Disable physics to maintain angles
        }
    };

    var network = new vis.Network(container, data, options);

    const SCALE_FACTOR = 20;
    function loadScheme() {
        var scheme = document.getElementById('schemeSelect').value;
        fetch(`/api/graph/${scheme}`)
            .then(response => response.json())
            .then(graph => {
                nodes.clear();
                edges.clear();

                let nodePositions = {};
                let visitedNodes = new Set();

                function dfs(nodeId, x, y) {
                    if (visitedNodes.has(nodeId)) return;
                    visitedNodes.add(nodeId);
                    nodePositions[nodeId] = { x, y };

                    graph.edges.forEach(edge => {
                        if (edge.from === nodeId && !visitedNodes.has(edge.to)) {
                            const length = (edge.length || 100) * SCALE_FACTOR;
                            const angle = (edge.direction - 90) % 360 || 0; //(edge.angle - 90) * (Math.PI / 180)
                            const radianAngle = angle * (Math.PI / 180);
                            const newX = x + length * Math.cos(radianAngle);
                            const newY = y + length * Math.sin(radianAngle);
                            dfs(edge.to, newX, newY);
                        } else if (edge.to === nodeId && !visitedNodes.has(edge.from)) {
                            const length = edge.length || 100;
                            const angle = edge.direction || 0;
                            const radianAngle = (angle + 180) * (Math.PI / 180);
                            const newX = x + length * Math.cos(radianAngle);
                            const newY = y + length * Math.sin(radianAngle);
                            dfs(edge.from, newX, newY);
                        }
                    });
                }

                if (graph.nodes.length > 0) {
                    dfs(graph.nodes[0].id, 0, 0);
                }

                graph.nodes.forEach(node => {
                    if (nodePositions[node.id]) {
                        node.x = nodePositions[node.id].x;
                        node.y = nodePositions[node.id].y;
                    }
                    nodes.add({
                        ...node,
                        shape: 'dot',
                        size: 10,
                        title: `Node ${node.id}`
                    });
                });

                edges.add(graph.edges.map(edge => ({
                    ...edge
                })));
            });
    }

    window.onload = function() {
        fetch('/api/graph/list')
            .then(response => response.json())
            .then(schemes => {
                var schemeSelect = document.getElementById('schemeSelect');
                schemes.forEach(schemeId => {
                    var option = document.createElement('option');
                    option.value = schemeId;
                    option.textContent = `Scheme id ${schemeId}`;
                    schemeSelect.appendChild(option);
                });
                schemeSelect.value = schemes[0];
                loadScheme();
            });
    };

    network.on("click", function (params) {
        if (params.nodes.length > 0) {
            var nodeId = params.nodes[0];
            var node = nodes.get(nodeId);
            displayDetails(node, 'Node');
        } else if (params.edges.length > 0) {
            var edgeId = params.edges[0];
            var edge = edges.get(edgeId);
            displayDetails(edge, 'Edge');
        }
    });

    network.on("dragEnd", function (params) {
        var movedNodeId = params.nodes[0];
        var positions = network.getPositions(movedNodeId);
        var movedNodePosition = positions[movedNodeId];

        // Обновляем координаты перемещенной ноды
        nodes.update({
            id: movedNodeId,
            x: movedNodePosition.x,
            y: movedNodePosition.y
        });

        updateEdgeLengthsAndAngles(movedNodeId);
    });

    function updateEdgeLengthsAndAngles(movedNodeId) {
        var movedNode = nodes.get(movedNodeId);

        edges.forEach(edge => {
            if (edge.from === movedNodeId || edge.to === movedNodeId) {
                var fromNode = nodes.get(edge.from);
                var toNode = nodes.get(edge.to);

                // Если перемещенная нода является начальной точкой ребра
                if (edge.from === movedNodeId) {
                    fromNode = movedNode;
                }

                // Если перемещенная нода является конечной точкой ребра
                if (edge.to === movedNodeId) {
                    toNode = movedNode;
                }

                var dx = toNode.x - fromNode.x;
                var dy = toNode.y - fromNode.y;

                var length = Math.sqrt(dx * dx + dy * dy) / SCALE_FACTOR;
                var angle = Math.atan2(dy, dx) * (180 / Math.PI);

                // Round length to nearest integer
                length = Math.round(length);

                // Round angle to nearest multiple of 5
                angle = Math.round(angle / 5) * 5;

                // Normalize angle to be positive
                if (angle < 0) {
                    angle += 360;
                }

                // Adjust direction based on whether the moved node is 'from' or 'to'
                var direction = (edge.from === movedNodeId) ? (angle + 90) % 360 : (angle + 270) % 360;

                console.log(`Updating edge ${edge.id}: length=${length}, angle=${angle}`);

                edges.update({
                    id: edge.id,
                    length: length,
                    direction: direction
                });

                //Принудительно обновляем положение узлов
                nodes.update([
                    { id: fromNode.id, x: fromNode.x, y: fromNode.y },
                    { id: toNode.id, x: toNode.x, y: toNode.y }
                ]);
            }
        });
        // Перерисовываем граф
        network.redraw();
    }

    function displayDetails(item, type) {
        var detailsDiv = document.getElementById('details');
        detailsDiv.innerHTML = `<h3>${type} Details</h3>`;
        for (var key in item) {
            if (item.hasOwnProperty(key)) {
                detailsDiv.innerHTML += `<p><strong>${key}:</strong> ${item[key]}</p>`;
            }
        }
    }

    function saveGraph() {
        var updatedGraph = {
            nodes: nodes.get(),
            edges: edges.get()
        };

        fetch('/api/graph', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(updatedGraph)
        });
    }

    function createScheme() {
        const schemeDescription = prompt("Enter a description for the new scheme:");
        const schemeLevel = prompt("Enter the level for the new scheme:");

        if (schemeDescription && schemeLevel) {
            fetch('/api/graph/scheme', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    description: schemeDescription,
                    nodes: [], // Starting with an empty list of vertices
                    edges: [], // Starting with an empty list of edges
                    level: schemeLevel
                })
            })
                .then(response => response.json())
                .then(newScheme => {
                    // Add new scheme to the dropdown
                    const schemeSelect = document.getElementById('schemeSelect');
                    const option = document.createElement('option');
                    option.value = newScheme.id;
                    option.textContent = `Scheme id ${newScheme.id}`;
                    schemeSelect.appendChild(option);

                    // Select the new scheme
                    schemeSelect.value = newScheme.id;
                    loadScheme();
                })
                .catch(error => {
                    console.error('Error creating new scheme:', error);
                });
        }
    }

    function addVertex() {
        const schemeId = document.getElementById('schemeSelect').value;
        const name = prompt("Enter the name for the new vertex:");
        const description = prompt("Enter the description for the new vertex:");
        const type = prompt("Enter the type for the new vertex (Cabinet, Port, Crossroad):");
        const availability = confirm("Is the vertex available?");

        if (schemeId && name && type) {
            fetch(`/api/graph/vertex`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    label: name,
                    description: description,
                    type: type,
                    availability: availability
                })
            })
                .then(response => response.json())
                .then(updatedScheme => {
                    // Update the graph with the new vertex
                    loadScheme();
                })
                .catch(error => {
                    console.error('Error creating and adding vertex:', error);
                });
        }
    }

    function addEdge() {
        const schemeId = document.getElementById('schemeSelect').value;
        const distance = prompt("Enter the distance for the new edge:");
        const vertexFromId = prompt("Enter the ID of the starting vertex:");
        const vertexToId = prompt("Enter the ID of the ending vertex:");
        const direction = prompt("Enter the direction for the new edge:");
        const type = prompt("Enter the type for the new edge (e.g., Vertical, Horizontal):");

        if (schemeId && distance && vertexFromId && vertexToId && direction && type) {
            fetch(`/api/scheme/${schemeId}/createEdge`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    distance: distance,
                    vertexFromId: vertexFromId,
                    vertexToId: vertexToId,
                    direction: direction,
                    type: type
                })
            })
                .then(response => response.json())
                .then(updatedScheme => {
                    // Update the graph with the new edge
                    loadScheme();
                })
                .catch(error => {
                    console.error('Error creating and adding edge:', error);
                });
        }
    }



</script>
</body>
</html>
